
# কখন জেনেরিকস ব্যবহার করবেন

এই সবের পরে, আপনি হয়তো সর্বত্র জেনেরিকস ব্যবহার করতে প্রলুব্ধ হতে পারেন। তবে যেকোনো টুলের মতো, জেনেরিকসেরও নিজস্ব স্থান রয়েছে। পিপিটি কখন এগুলো সবচেয়ে দরকারী বলে মনে করেছে তা এখানে দেওয়া হলো:

১. **যখন বিভিন্ন টাইপের জন্য একই কার্যকারিতা প্রয়োজন**: কালেকশন, ডেটা কন্টেইনার, রেজাল্ট র‍্যাপার।
২. **যখন আপনি টাইপের তথ্য সংরক্ষণ করতে চান**: `Object` ব্যবহার করে কাস্টিং করার পরিবর্তে।
৩. **যখন আপনি কম্পাইল-টাইম টাইপ নিরাপত্তা চান**: রানটাইমের আগে টাইপ এরর ধরা।
৪. **যখন আপনি পুনঃব্যবহারযোগ্য কম্পোনেন্ট তৈরি করছেন**: লাইব্রেরি, ফ্রেমওয়ার্ক এবং ইউটিলিটি।

এবং কখন পিপিটি এগুলো এড়িয়ে গেছে তা এখানে দেওয়া হলো:

১. **যখন শুধুমাত্র একটি টাইপ ব্যবহার করবেন**: যদি আপনি শুধুমাত্র স্ট্রিং নিয়ে কাজ করেন তবে জেনেরিকসের প্রয়োজন নেই।
২. **যখন টাইপ ইরেজার একটি উদ্বেগের বিষয়**: মনে রাখবেন যে জেনেরিক টাইপের তথ্য রানটাইমে মুছে ফেলা হয়।
৩. **যখন এটি কোড বুঝতে কঠিন করে তোলে**: কখনও কখনও স্পষ্ট টাইপ আরও পরিষ্কার হয়।

## উপসংহার: পিপিটির পরিবর্তন

জেনেরিকস গ্রহণ করে, পিপিটি তার কোডবেসকে রূপান্তরিত করেছে:

- **আগে**: বিভিন্ন ডেটা টাইপের জন্য ২০টিরও বেশি অনুরূপ ক্লাস
- **পরে**: ~৫টি জেনেরিক ক্লাস যা সমস্ত ডেটা টাইপ হ্যান্ডেল করে

- **আগে**: সর্বত্র কোড ডুপ্লিকেশন
- **পরে**: একবার লিখুন, যেকোনো টাইপের জন্য ব্যবহার করুন

- **আগে**: ডেটা প্রসেস করার সময় রানটাইম টাইপ এরর
- **পরে**: কম্পাইল-টাইম টাইপ চেকিং

তবে সবচেয়ে গুরুত্বপূর্ণ, যখন একটি নতুন ডেটা টাইপের প্রয়োজন ছিল:

- **আগে**: একটি নতুন ক্লাস, নতুন প্রসেসিং লজিক, নতুন স্টোরেজ হ্যান্ডলার লিখুন
- **পরে**: কেবল বিদ্যমান জেনেরিক অবকাঠামো ব্যবহার করুন

এখন আপনার পালা। আপনার নিজের কোডবেসের দিকে তাকান—কোথায় আপনি বিভিন্ন টাইপের জন্য নিজেকে পুনরাবৃত্তি করছেন? কোথায় জেনেরিকস আপনার কোডকে আরও সংক্ষিপ্ত, নিরাপদ এবং আরও নমনীয় করতে পারে?

## চ্যালেঞ্জ অনুশীলন

যাওয়ার আগে, আপনার জন্য আমার একটি চ্যালেঞ্জ আছে। `Result<S, E>` নামে একটি ক্লাস প্রয়োগ করার চেষ্টা করুন যা `S` টাইপের একটি সাফল্যের মান বা `E` টাইপের একটি ত্রুটি মান উপস্থাপন করে। এই প্যাটার্নটি Rust-এর মতো ভাষাগুলিতে সাধারণ এবং ডার্টে ত্রুটি হ্যান্ডলিংয়ের উন্নতি ঘটাতে পারে। আপনাকে শুরু করার জন্য এখানে একটি স্কেচ দেওয়া হলো:

```dart
class Result<S, E> {
  final S? _success;
  final E? _error;
  final bool isSuccess;
  
  Result.success(S value)
      : _success = value,
        _error = null,
        isSuccess = true;
  
  Result.error(E error)
      : _success = null,
        _error = error,
        isSuccess = false;
  
  // TODO: Implement methods like:
  // - getOrElse(S defaultValue)
  // - map<T>(T Function(S) mapper)
  // - mapError<F>(F Function(E) mapper)
  // - flatMap<T>(Result<T, E> Function(S) mapper)
}
```

দেখুন আপনি এই ক্লাসটি সম্পূর্ণ করতে এবং একটি ব্যবহারিক উদাহরণে এটি ব্যবহার করতে পারেন কিনা। শুভকামনা!
